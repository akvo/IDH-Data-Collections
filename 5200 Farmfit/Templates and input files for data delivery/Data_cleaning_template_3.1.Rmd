---
title: "Data_cleaning_[country]_[crop]"
output: html_document
date: "2025-03-12"
---

```{r setup, include=FALSE}
rm(list = ls(), envir = .GlobalEnv)
knitr::opts_chunk$set(echo = TRUE)
```

This script is developed to clean data from IDH cases in a standardized way.

### Preparation

Load the necessary packages.

```{r, include = FALSE}
library(here); library(readxl); library(openxlsx);
library(plyr); library(dplyr); library(tidyr); library(tidylog); library(tidyselect)
library(stringr); library(data.table); library(reshape2)
library(zoo);library(splitstackshape) ;library(tidyverse); library(magrittr)
```

Fill in the basic case information.

```{r}
case = "Okomu"
year = "2025"
focus_crop = "palm_oil"
country = "Nigeria"
```

Make a new Github map with the project name where this R Markdown file is stored, together with the raw data and the survey form downloaded from Flow. Fill in the right file names in the code below so the variables data_filename and survey_filename refer to the correct file.

```{r}
data_filename <- "DATA_ANALYSIS-647230002-Okomu endline.xlsx"
survey_filename <- "SURVEY_FORM-647230002-Okomu endline.xlsx"
```

Describe the files that will be created in the script here.

```{r}
pi_filename <- paste("pi_",year,"_",case,"_",focus_crop,".xlsx", sep="")
data_delivery <- paste(year,"_",case,"_anom_",focus_crop,"_endline",".xlsx", sep = "")
```

Import the data files that can be found in the map Analytics-Guild -\> IDH -\> Templates and input files for data delivery. Copy them in the project map.

```{r}
question_library <- read_excel("question library format v4.1.1.xlsx",
                               sheet = "Full Survey", skip = 2) 
vars_transformed <- read_excel("variables with transformation_2.xlsx") 
household_demographics  <- read_excel("household_demographics_var_2.xlsx") 
vars_dashboard <- read_excel("variable names input dashboard_2.xlsx") 

```

Define functions that will be needed later in the script.

```{r}
# DATA TYPE: Set factors to integers
factor_to_int <- function(x){
  if (is.factor(x) || is.character(x)) {
    return(as.numeric(as.character(x)))
  } else {
    return(as.numeric(x))
  }
}

# Find and replace outliers
outlier_detection <- function(x){
  ifelse(
    x > (mean(x, na.rm=TRUE) + sd(x, na.rm=TRUE)*3) |
      x < (mean(x, na.rm=TRUE) - sd(x, na.rm=TRUE)*3), 
    9997,
    x
  )
}

# Avoid scientific notation in printed numbers
options(scipen = 999) 

# count values without NA
count_n <- function(x){sum(!is.na(x))}
```

### Import data

We read the data downloaded. The below is for a KOBO format. On Data we will perform cleaning. Data_raw will be added to the data delivery as the full raw data file without transformations. Only the personal information variables are removed.

**Note**: specify the correct sheet name

```{r, include = FALSE}
# Data for transformation
Data <- read_excel(data_filename, sheet = "Farmer survey Okomu Nigeria")
focus_repeat_revenue <- read_excel(data_filename, sheet = "focus_repeat_revenue")

# Read file with survey structure
survey_questions <- read_excel((survey_filename),sheet ="survey")
questions_choices <- read_excel ((survey_filename), sheet ="choices")
```

Execute mapping so that columns are not questions but variable names. 

```{r}
# Prepare the mapping
question_to_variable <- survey_questions %>%
  filter(!is.na(`label::English`)) %>%
  select(`label::English`, name)

mapping_dict <- setNames(question_to_variable$name, question_to_variable$`label::English`)

# Rename columns in Data, including support for question_text/answer_option format
new_names <- names(Data)

new_names <- sapply(new_names, function(col_name) {
  if (col_name %in% names(mapping_dict)) {
    # Exact match
    return(mapping_dict[[col_name]])
  } else if (grepl("/", col_name, fixed = TRUE)) {
    # Handle multiple choice columns
    parts <- strsplit(col_name, "/", fixed = TRUE)[[1]]
    question_part <- parts[1]
    option_part <- parts[2]
    
    if (question_part %in% names(mapping_dict)) {
      return(paste0(mapping_dict[[question_part]], "/", option_part))
    }
  }
  return(col_name)  # Return as-is if no match
})

# Apply new column names
names(Data) <- new_names

# Verify the result
head(Data)
```

Set the raw data file based on the mapped Data 

```{r}
# Raw data 
Data_raw <- Data
## ---- Extract personal information ----
Data_raw <- Data_raw %>%
  select(-contains("--option--")) %>% #how to deal with that in kobo format?
  rename_all(funs(tolower)) %>%
  select(uuid,
         name_of_farmer,
         mobile_number_farmer,
         contains("pi_")) #-contains("ppi")) 


pi_info<- list("Personal information" = Data_raw)

write.xlsx(pi_info, file=pi_filename) #pi_filename was created in the beginning of the script

#Anonymise
Data_raw <- Data_raw %>%
  select(-starts_with("pi_"), -name_of_farmer, -mobile_number_farmer)

Data_focus_repeat_raw <- read_excel(data_filename, sheet = "focus_repeat_revenue")
```


Adjust the survey file to be ready for analysis. We now have a clear overview of the survey questions asked in this case. The below code is for Kobo format

```{r, include = FALSE}
# SURVEY QUESTION SHEET

survey_questions %<>%
  # Select relevant columns: type, name, label in English, and relevant
  select(type, name, `label: English`, `label: Portuguese`, relevant) %>%
  # Trim any trailing spaces from character columns
  mutate(across(where(is.character), str_trim)) %>%
  # Rename "label: English" to a simpler "label"
  rename(label = `label: English`) %>%
  # Convert all data to lowercase for consistency
  mutate(across(everything(), tolower)) %>%
  # Filter out rows where the 'type' column is missing (empty rows)
  filter(!is.na(type)) %>%
  # Filter out rows where the 'label' column is missing (empty rows)
  filter(!is.na(label)) %>%
  # Filter out rows where the type is 'note', 'begin_group', or 'begin_repeat'
  filter(!type %in% c("note", "begin_group", "begin group", "begin_repeat"))

# CHOICES QUESTION SHEET
questions_choices %<>%
  # Select relevant columns: list_name, name, label in English, and label in Portuguese
  select(list_name, name, `label: English`, `label: Portuguese`) %>%
  # Trim any trailing spaces from character columns
  mutate(across(where(is.character), str_trim)) %>%
  # Rename "label: English" to "label" and "list_name" to "choices_name"
  rename(label = `label: English`, choices_name = list_name) %>%
  # Convert all data to lowercase for consistency
  mutate(across(everything(), tolower)) %>%
  # Filter out rows where the 'choices_name' column is missing (empty rows)
  filter(!is.na(choices_name))
```

What are the numerical columns? How many participants?

```{r}
# Collect the different variables, numerical questions:
numerical_columns <- survey_questions %>%
  filter(type %in% c("integer", "decimal")) %>%
  select("name") %>% pull()
numerical_columns

## ---- Count initial number of participants
nr_participants_raw <- length(unique(Data$`_uuid`))
nr_participants_raw

```

# Section 1. Cleaning the data

## 1. Rename variables where necessary

```{r}
Data <- Data %>%
  rename(uuid = `_uuid`) 
```

## 2. Standard data cleaning (dates, columns, lowercase, participation, duplicates)

```{r, include = FALSE}
Data <- Data %>%
  # Set the date to date format
  mutate(`_submission_time` = as.Date(`_submission_time`, format = "%d-%m-%Y")) %>%
  # Remove irrelevant columns
  select(-c(devicephonenum, deviceid, subscriberid, simid, 
            `__version__`, `_validation_status`, `_notes`, `_status`, `_submitted_by`, `_tags`, 
            )) %>%
  select(-contains("--option--")) %>%
  # All column names to lowercase
  rename_all(tolower) %>%
  # Remove farmers who didnâ€™t participate
  filter(surv_consent != "Refused to participate") %>%
  # Remove completely empty columns
  select(where(~ !all(is.na(.))))
```

## 3. Other variables

Identify the "other" variables, and combine the values with their parent. Then the "other" variables are removed.

```{r, include = FALSE}
variables_other <- Data %>% 
  select(ends_with("_other"), ends_with("_other2")) %>% 
  names() 

for(other in variables_other){
  
  if(any(names(Data) %in% gsub("_other$|_other2$", "", other))){
    
    # Fuzzy match? - many spelling mistakes in "other" questions
    
    # Combine "other" variables with their parents
    Data <- Data %>%
      unite(!!gsub("_other$|_other2$", "", other), 
            c(gsub("_other$|_other2$", "", other), all_of(other)), 
            sep="|", remove=FALSE, na.rm=TRUE) %>%
      select(-other)
  }
}
```
## 4. Correct prices, quantities

```{r}
# Data <- Data %>%
#   mutate(f_focus_price = ifelse(uuid=="47a5f878-8d38-4ca1-929d-2710f9f7c6d0", 1175,
#                                 ifelse(uuid=="6db21e1c-9a4b-4252-9a23-dc7655f0c602", 120,f_focus_price)))
# 
# 
# #calculate median to be used when needed
# median_price<- Data %>%
#    summarize(median_price = median(f_focus_price, na.rm = TRUE))
# #wrong price but enumerator don't remember
# Data <- Data %>%
#   mutate(f_focus_price= ifelse(uuid=="21d51199-d16d-4b4a-a1c7-073740e26e00", median_price$median_price, f_focus_price))
```


## 5. Specific adjustments for quantities and measurement units

This is case specific.

```{r}
#   Data <- Data %>%
#     mutate(f_focus_quant_prod = ifelse(uuid =="df4b4aa7-dba4-44e4-9c46-7daae3db6801", 2500,
#                                        ifelse(uuid =="b3f1b249-cd7f-4601-9c5e-139bb77c0d5a", 224,
#                                        f_focus_quant_prod)),
#                       f_focus_quant_sold = ifelse(uuid == "5fdf2061-dbb1-4e95-a4a2-0dacf9aa58cf", 1368, 
#                                        ifelse(uuid == "c628f514-2650-4e41-b6c5-0b59ca21a7ed", 40, f_focus_quant_sold)))
# 
# # #quantity sold>prod
#   Data <- Data %>%
#      mutate(f_focus_quant_sold=ifelse(f_focus_quant_prod > 0 & f_focus_quant_sold > f_focus_quant_prod, f_focus_quant_prod, f_focus_quant_sold))
```

Measurement unit

```{r}
# THIS IS EXAMPLE CODE! ADAPT THE CODE TO THE NECESSARY ADJUSTMENTS IN THE CASE, OR DELETE CODE IF NO CLEANING IS REQUIRED
# Data <- Data %>%
#   mutate(
#     #prod
#     f_focus_measurement_prod = ifelse(f_focus_quant_prod != 0 & f_focus_measurement_prod == "", "kgs", f_focus_measurement_prod))
#     #sold
#     #   harmonise measurement unit 
#       f_focus_measurement_sold = ifelse(f_focus_measurement_sold == "100 kilogram bags", "100 kgs bags", f_focus_measurement_sold)

```

## 6. Handle outliers and missing values

Exclude variables such as quantities, price and farm size to be checked manually.

```{r, include = FALSE}
excluded_columns <- c("f_size", "f_focus_crop_size", "f_focus_quant_prod", "f_focus_quant_sold", "f_focus_quant_lost", "f_focus_own_consumption") # Replace with actual variable names

# Identify numerical columns for outlier handling, excluding those ending with "_#"
numerical_columns <- names(Data %>% select_if(is.numeric)) %>%
  .[!grepl("_\\d+$", .)]  %>%  # Exclude columns ending with "_#"
  .[!(. %in% excluded_columns)] %>%  # Exclude specific columns
  .[sapply(Data[.], function(x) length(unique(x)) > 2)]  # Exclude binary columns
```

The following piece of code will delete outliers. 

!! Make sure to only run this code AFTER the productivity check !! 

```{r, include = FALSE}
# Apply the outlier detection function to numerical columns
Data <- Data %>%
    mutate_at(vars(numerical_columns), funs(outlier_detection)) %>%
  
# Replace specific values (9999, 9998, 9997) with NA for numeric columns
  mutate_if(is.numeric, list(~na_if(., 9999))) %>%
  mutate_if(is.numeric, list(~na_if(., 9998))) %>%
  mutate_if(is.numeric, list(~na_if(., 9997)))

# Change "I don't know" and "I prefer not to say" into NAs
Data <- Data %>%
  mutate_if(is.character, list(~na_if(., "i don't know"))) %>%
  mutate_if(is.character, list(~na_if(., "i prefer not to say")))

```

**Data activities**

```{r}
# Identify numerical columns for outlier handling, excluding those ending with "_#"
numerical_columns <- names(Data_activities %>% select_if(is.numeric)) %>%
  .[!grepl("_\\d+$", .)]  %>%  # Exclude columns ending with "_#"
  .[sapply(Data_activities[.], function(x) length(unique(x)) > 2)]  # Exclude binary columns

# Apply the outlier detection function to numerical columns
Data_activities <- Data_activities %>%
    mutate_at(vars(numerical_columns), funs(outlier_detection)) %>%

  # Replace specific values (9999, 9998, 9997) with NA for numeric columns
  mutate_if(is.numeric, list(~na_if(., 9999))) %>%
  mutate_if(is.numeric, list(~na_if(., 9998))) %>%
  mutate_if(is.numeric, list(~na_if(., 9997))) %>%

  # Replace "I don't know" or "I prefer not to say" with NA for character columns
  mutate_if(is.character, list(~na_if(., "i don't know"))) %>%
  mutate_if(is.character, list(~na_if(., "i prefer not to say")))
```

**Data hh labour**

```{r}
# Identify numerical columns for outlier handling, excluding those ending with "_#"
numerical_columns <- names(Data_labour %>% select_if(is.numeric)) %>%
  .[!grepl("_\\d+$", .)]   %>%  # Exclude columns ending with "_#"
  .[sapply(Data_labour[.], function(x) length(unique(x)) > 2)]  # Exclude binary columns

# Apply the outlier detection function to numerical columns
Data_labour <- Data_labour %>%
    mutate_at(vars(numerical_columns), funs(outlier_detection)) %>%

  # Replace specific values (9999, 9998, 9997) with NA for numeric columns
  mutate_if(is.numeric, list(~na_if(., 9999))) %>%
  mutate_if(is.numeric, list(~na_if(., 9998))) %>%
  mutate_if(is.numeric, list(~na_if(., 9997))) %>%

  # Replace "I don't know" or "I prefer not to say" with NA for character columns
  mutate_if(is.character, list(~na_if(., "i don't know"))) %>%
  mutate_if(is.character, list(~na_if(., "i prefer not to say")))
```

## 7. Adjust Farm Size

Adjust the **farm sizes** to acres.

```{r}
# First check what are the unit measurements reported in this case.
table(Data$f_unit_land)
#table(Data$f_unit_land_other2)
```

```{r}
# THIS IS EXAMPLE CODE! ADAPT THE CODE TO THE NECESSARY ADJUSTMENTS IN THE CASE, OR DELETE CODE IF NO CLEANING IS REQUIRED
# Data <- Data %>%
#   mutate(f_focus_crop_size = ifelse(f_size < f_focus_crop_size, NA, f_focus_crop_size))
#                                     
```

The code below creates a variable for farm sizes in both acres and hectares. When another option is given as unit of measurement (other than acres or hectares), the code needs to be manually adjusted!

```{r, include = FALSE}

#Mutate the different units to acres. We need a farm size in acres for the total farm size, and the size dedicated to focus crop.
Data <- Data %>%
#Convert land size to acres if in hectares
 mutate(f_size_acre = ifelse(f_unit_land == "hectares", f_size * 2.471, f_size)) %>%
 mutate(f_focus_crop_size_acre = ifelse(f_unit_land == "hectares", f_focus_crop_size * 2.471, f_focus_crop_size)) %>%
#Mutate the different units to hectares. We need a farm size in hectares for the total farm size, and the size dedicated to focus crop.
 mutate(f_size_hectare = ifelse(f_unit_land == "hectares", f_size, f_size_acre / 2.471)) %>%
 mutate(f_focus_crop_size_hectare = ifelse(f_unit_land == "hectares", f_focus_crop_size, f_focus_crop_size_acre / 2.471))
```

## 8. Some statistics

```{r}
# Number of participants who gave informed consent 
nr_participants_ic <- length(unique(Data$uuid))

# NUMBER OF SEASONS
number_of_seasons <- max(Data$f_harvest_num, na.rm=TRUE)
```

# Section 2. Actual income calculation

## 1) Transform unit measurements

Each unit measurement variables needs to be aligned. let's handle the transformation of unit measurements for production, sales, consumption and losses. We transform every variable to kg.

First check what are the unit measurement reported in this case. Use the code below, or check the google looker dashboard.

```{r}
table(Data$f_focus_measurement_prod)
table(Data$f_focus_measurement_sold)
table(Data$f_focus_measurement_lost)
```

To do so, we extract the numerical values from the measurement units for quantity produced, sold, consumed and lost. Always check by hand whether this is going well. We extract the numbers from the measurement units to calculate total quantities. If there are other measurement units, not related to kg, put a value for those in the variable: cal_focus_measurement_prod

**Measurement unit production**

```{r, include = FALSE}
# Add to this code the different measurement units that are applicable in the case
Data <- Data %>%
  mutate(
    cal_focus_measurement_prod = case_when(
      grepl("[[:digit:]]", f_focus_measurement_prod) ~ parse_number(f_focus_measurement_prod),
      f_focus_measurement_prod %in% c("kg", "Kgs") ~ 1,
      TRUE ~ 0
    )
  )
# Create a dataframe with only the two columns to check whether the calculation went allright
check_measurement_conversion <- Data %>%
  select(f_focus_measurement_prod, cal_focus_measurement_prod)

```

**Measurement unit sales**

```{r, include = FALSE}
Data <- Data %>%
  mutate(
    cal_focus_measurement_sold = case_when(
      grepl("[[:digit:]]", f_focus_measurement_sold) ~ parse_number(f_focus_measurement_sold),
      f_focus_measurement_sold %in% c("kg", "Kgs") ~ 1,
      f_focus_measurement_sold == "Tonnes" ~ 1000,
       TRUE ~ 0
    )
  )

# Create a dataframe with only the two columns to check whether the calculation went allright
check_measurement_conversion_sold <- Data %>%
  select(f_focus_measurement_sold, cal_focus_measurement_sold)

```

**Measurement unit focus crop lost**

```{r, include = FALSE}
Data <- Data %>%
  mutate(
    cal_focus_measurement_lost = case_when(
      grepl("[[:digit:]]", f_focus_measurement_lost) ~ parse_number(f_focus_measurement_lost),
      cal_focus_measurement_lost %in% c("kg", "Kgs") ~ 1,
      cal_focus_measurement_lost == "Tonnes" ~ 1000,
      TRUE ~ 0
    )
  )

# Create a dataframe with only the two columns to check whether the calculation went allright
check_measurement_conversion_lost <- Data %>%
  select(f_focus_measurement_lost, cal_focus_measurement_lost)
```

**Measurement unit focus crop own consumption**

```{r, include = FALSE}
Data <- Data %>%
  mutate(
    cal_focus_measurement_own_consumption = case_when(
      grepl("[[:digit:]]", f_focus_own_consumption_measurement) ~ parse_number(f_focus_own_consumption_measurement),
      cal_focus_measurement_own_consumption %in% c("kg", "Kgs") ~ 1,
      TRUE ~ 0
    )
  )

# Create a dataframe with only the two columns to check whether the calculation went allright
check_measurement_conversion_owncon <- Data %>%
  select(f_focus_own_consumption_measurement, cal_focus_measurement_own_consumption)
```

## 2) Quantities produced, sold, lost and own consumption

In this section the quantities produced, sold, lost and own consumption are cleaned. Now that the unit measurements are transformed, the quantities produced, sold, lost and own consumption can be calculated in kgs.

```{r, include = FALSE}
Data <- Data %>%
    # Convert relevant columns to numeric
  mutate(across(c(f_focus_quant_prod, cal_focus_measurement_prod, f_focus_quant_sold, cal_focus_measurement_sold, f_focus_quant_lost, cal_focus_measurement_lost, 
                  f_focus_price), as.numeric)) %>%
  ##Calculate the quantities focus crop
  mutate(cal_focus_quant_prod_kg = f_focus_quant_prod * cal_focus_measurement_prod) %>%
  mutate(cal_focus_quant_sold_kg = f_focus_quant_sold * cal_focus_measurement_sold) %>%
  mutate(cal_focus_quant_lost_kg = f_focus_quant_lost * cal_focus_measurement_lost) %>%
  mutate(cal_focus_quant_own_consumption_kg = f_focus_own_consumption * cal_focus_measurement_own_consumption)%>%
  mutate_at(vars(starts_with("cal_focus_quant")), ~replace_na(., 0)) 
    
  # also calculate the unit price 
Data <- Data %>%
  mutate(cal_focus_price = ifelse(cal_focus_measurement_prod != 0, f_focus_price/cal_focus_measurement_sold, f_focus_price),
    cal_focus_price = ifelse(is.na(cal_focus_quant_sold_kg) | cal_focus_quant_sold_kg == 0, NA, cal_focus_price))%>%
  mutate(cal_focus_price = replace_na(cal_focus_price, 0))
```

```{r, include = FALSE}
#Replace Price NA with median if there is record of sale
Data <- Data %>%
  mutate(cal_focus_price = ifelse(cal_focus_quant_sold_kg > 0 & is.na(cal_focus_price), median(cal_focus_price), cal_focus_price))
```

Check whether the calculations went well. We make a subset of the data with relevant variables. Click on the dataset to sort the columns to detect strange numbers and solve if necessary.

```{r, include = FALSE}

quantities_produced_subset <- Data %>% select(f_focus_measurement_prod, cal_focus_measurement_prod, f_focus_quant_prod, cal_focus_quant_prod_kg)

quantities_sold_subset <- Data %>% select(f_focus_measurement_sold, cal_focus_measurement_sold, f_focus_quant_sold, cal_focus_quant_sold_kg)

quantities_lost_subset <- Data %>% select(f_focus_measurement_lost, cal_focus_measurement_lost, f_focus_quant_lost, cal_focus_quant_lost_kg)

quantities_own_consumption_subset <- Data %>% select(f_focus_own_consumption_measurement, cal_focus_measurement_own_consumption, f_focus_own_consumption, cal_focus_quant_own_consumption_kg)

price_subset <- Data %>% select(f_focus_price, cal_focus_measurement_prod, cal_focus_price)
```

Tabulate some stats to check data quality, then make adjustments above in section 1

```{r}

# Create a boxplot of price
boxplot(Data$cal_focus_price_kg, ylab="Price of coffee per kg",
        main="Boxplot of coffee price", col="red", las=1, cex.lab=1.2)

# Create a boxplot of quantity prod
boxplot(Data$cal_focus_quant_prod_kg, ylab="quantity produced",
        main="Boxplot of quantity produced", col="red", las=1, cex.lab=1.2)

# Create a boxplot of quantity sold
boxplot(Data$cal_focus_quant_sold_kg, ylab="quantity sold",
        main="Boxplot of quantity sold", col="red", las=1, cex.lab=1.2)

# Create a boxplot of quantity lost
boxplot(Data$cal_focus_quant_lost_kg, ylab="quantity lost",
        main="Boxplot of quantity lost", col="red", las=1, cex.lab=1.2)

# Create a boxplot of quantity consumed
boxplot(Data$cal_focus_quant_own_consumption_kg, ylab="quantity consumed",
        main="Boxplot of quantity consumed", col="red", las=1, cex.lab=1.2)

# Filter the data and tabulate the uuid when price=0 but we have sales
Data %>%
  filter(cal_focus_price_kg == 0 & cal_focus_quant_sold_kg > 0) %>%
  select(uuid, cal_focus_price_kg, cal_focus_quant_sold_kg)  # Select relevant columns

# Filter the data and tabulate the uuid when prod is lower than sales
Data %>%
  filter(cal_focus_quant_sold_kg > cal_focus_quant_prod_kg) %>%
  select(uuid, f_focus_quant_prod, f_focus_measurement_prod, f_focus_quant_sold, f_focus_measurement_sold, f_focus_crop_size_hectare)  # Select relevant columns

Data %>%
  filter(cal_focus_quant_sold_kg == 0 & cal_focus_quant_prod_kg == 0) %>%
  select(uuid, f_focus_crop_size_hectare, f_focus_quant_prod, f_focus_quant_sold, cal_focus_price_kg)

Data %>%
  filter(cal_focus_quant_sold_kg == 0 & cal_focus_price_kg > 0) %>%
  select(uuid, cal_focus_price_kg, cal_focus_quant_sold_kg)
```

## 3) Focus crop revenue calculation

check the revenue time period and harmonize if not

```{r}
# Check how many seasons there are to adjust the following code 
# table(Data$f_focus_rev_timeperiod)
```

```{r}
# #harmonise season if not
# Data <- Data %>%
#   mutate(f_focus_rev_timeperiod=ifelse(f_focus_rev_timeperiod=="season 1 timeframe", "season 1",
#                                        ifelse(f_focus_rev_timeperiod== "season 2 timefrmae", "season 2" ,
#                                               f_focus_rev_timeperiod)))
```

Calculate the revenue (globally and per season). make sure the name of season is updated (if not labeled in the same way) in the code below

```{r, include = FALSE}
Data <- Data %>%
  mutate(cal_focus_revenue = cal_focus_quant_sold_kg * cal_focus_price,
         cal_focus_revenue = replace_na(cal_focus_revenue, 0))
   
# Create extra columns to define the quantities per season
Data <- Data %>%
  # Create new columns based on the season specified in f_focus_rev_timeperiod
  mutate(
    cal_focus_quant_prod_kg_season_1 = ifelse(f_focus_rev_timeperiod == "season 1", cal_focus_quant_prod_kg, NA),
    cal_focus_quant_prod_kg_season_2 = ifelse(f_focus_rev_timeperiod == "season 2", cal_focus_quant_prod_kg, NA),
    cal_focus_quant_prod_kg_whole_year = ifelse(f_focus_rev_timeperiod == "past 12 months whole year", cal_focus_quant_prod_kg, NA), #   
    cal_focus_quant_sold_kg_season_1 = ifelse(f_focus_rev_timeperiod == "season 1", cal_focus_quant_sold_kg, NA),
    cal_focus_quant_sold_kg_season_2 = ifelse(f_focus_rev_timeperiod == "season 2", cal_focus_quant_sold_kg, NA),
    cal_focus_quant_sold_kg_whole_year = ifelse(f_focus_rev_timeperiod == "past 12 months whole year", cal_focus_quant_sold_kg, NA),
#
    cal_focus_quant_own_consumption_kg_season_1 = ifelse(f_focus_rev_timeperiod == "season 1", cal_focus_measurement_own_consumption, NA),
    cal_focus_quant_own_consumption_kg_season_2 = ifelse(f_focus_rev_timeperiod == "season 2", cal_focus_measurement_own_consumption, NA),
    cal_focus_quant_own_consumption_kg_whole_year = ifelse(f_focus_rev_timeperiod == "past 12 months whole year", cal_focus_measurement_own_consumption, NA),
#
    cal_focus_quant_lost_kg_season_1 = ifelse(f_focus_rev_timeperiod == "season 1", cal_focus_quant_lost_kg, NA),
    cal_focus_quant_lost_kg_season_2 = ifelse(f_focus_rev_timeperiod == "season 2", cal_focus_quant_lost_kg, NA),
    cal_focus_quant_lost_kg_whole_year = ifelse(f_focus_rev_timeperiod == "past 12 months whole year", cal_focus_quant_lost_kg, NA)
  )

##X) STANDARD APPROACH Inbetween, adjust for repeated question groups (IF APPLICABLE)  ----  
     ##Adress values for those that have multiple seasons

Data <- Data %>%
  #Identify duplicates
  group_by(identifier, f_focus_rev_timeperiod) %>% 
  mutate(count_dup = n()) %>% # Count duplicates within each group
  mutate(count_dup = ifelse(is.na(f_focus_rev_timeperiod), NA, count_dup)) %>% # Check whether we don't make mistakes here. For some cases, farmers enter twice wrongly, while in other cases entering the same values for 2 seasons is ok.
  
  #Identify those with multiple seasons
  group_by(identifier, f_focus_rev_timeperiod) %>% 
  mutate(count_seasons = n()) %>% # Count the number of seasons for each group
  mutate(count_seasons = ifelse(is.na(f_focus_rev_timeperiod) | count_seasons > 1, NA, count_seasons)) %>%

  # Sum the quantities for those that entered data for multiple seasons
  group_by(identifier) %>%
  mutate(
    cal_focus_quant_prod_kg_season_1 = sum(na.omit(cal_focus_quant_prod_kg_season_1), na.rm = TRUE),
    cal_focus_quant_prod_kg_season_2 = sum(na.omit(cal_focus_quant_prod_kg_season_2), na.rm = TRUE),
    cal_focus_quant_prod_kg_whole_year = sum(na.omit(cal_focus_quant_prod_kg_whole_year), na.rm = TRUE),
    cal_focus_quant_sold_kg_season_1 = sum(na.omit(cal_focus_quant_sold_kg_season_1), na.rm = TRUE),
    cal_focus_quant_sold_kg_season_2 = sum(na.omit(cal_focus_quant_sold_kg_season_2), na.rm = TRUE),
    cal_focus_quant_sold_kg_whole_year = sum(na.omit(cal_focus_quant_sold_kg_whole_year), na.rm = TRUE), 
    cal_focus_quant_own_consumption_kg_season_1 = sum(na.omit(cal_focus_quant_own_consumption_kg_season_1), na.rm = TRUE),
    cal_focus_quant_own_consumption_kg_season_2 = sum(na.omit(cal_focus_quant_own_consumption_kg_season_2), na.rm = TRUE),
    cal_focus_quant_own_consumption_kg_whole_year = sum(na.omit(cal_focus_quant_own_consumption_kg_whole_year), na.rm = TRUE),
    cal_focus_quant_lost_kg_season_1 = sum(na.omit(cal_focus_quant_lost_kg_season_1), na.rm = TRUE),
    cal_focus_quant_lost_kg_season_2 = sum(na.omit(cal_focus_quant_lost_kg_season_2), na.rm = TRUE),
    cal_focus_quant_lost_kg_whole_year = sum(na.omit(cal_focus_quant_lost_kg_whole_year), na.rm = TRUE)
  ) %>% 
  
  #Replace values with 0 for those that entered the data twice 
  mutate(`repeat no` = as.numeric(`repeat no`)) %>%
  mutate(cal_focus_quant_prod_kg = ifelse(`repeat no` >1  & count_dup > 1, 0, cal_focus_quant_prod_kg)) %>%
  mutate(cal_focus_quant_sold_kg = ifelse(`repeat no` >1  & count_dup > 1, 0, cal_focus_quant_sold_kg)) %>%
  mutate(cal_focus_quant_own_consumption_kg = ifelse(`repeat no` >1  & count_dup > 1, 0, cal_focus_quant_own_consumption_kg )) %>%
  mutate(cal_focus_quant_lost_kg = ifelse(`repeat no` >1  & count_dup > 1, 0, cal_focus_quant_lost_kg)) %>%
  mutate(cal_focus_revenue = ifelse(`repeat no` >1  & count_dup > 1, 0, cal_focus_revenue)) %>%

  #Sum the quantities for those that entered data for multiple seasons
  group_by(identifier, count_seasons) %>%
  mutate(cal_focus_quant_prod_kg =  sum(cal_focus_quant_prod_kg)) %>%
  mutate(cal_focus_quant_sold_kg =  sum(cal_focus_quant_sold_kg)) %>%
  mutate(cal_focus_quant_own_consumption_kg =  sum(cal_focus_quant_own_consumption_kg)) %>%
  mutate(cal_focus_quant_lost_kg =  sum(cal_focus_quant_lost_kg)) %>%
  mutate(cal_focus_revenue = sum(cal_focus_revenue)) %>%

  #Ensure we have 1 row of data for each farmer
  mutate(cal_focus_quant_prod_kg = ifelse(`repeat no` >1 , NA, cal_focus_quant_prod_kg)) %>%
  mutate(cal_focus_quant_sold_kg = ifelse(`repeat no` >1  , NA, cal_focus_quant_sold_kg)) %>%
  mutate(cal_focus_quant_own_consumption_kg = ifelse(`repeat no` >1  , NA, cal_focus_quant_own_consumption_kg )) %>%
  mutate(cal_focus_quant_lost_kg = ifelse(`repeat no` >1 , NA, cal_focus_quant_lost_kg)) %>%
  mutate(cal_focus_revenue = ifelse (`repeat no`>1, NA, cal_focus_revenue)) %>%
  ungroup() %>%
  select(-count_dup, -count_seasons)

##Replace missing values in focus revenue by zero
Data <- Data %>%
  mutate(cal_focus_revenue = ifelse(is.na(cal_focus_revenue), 0, cal_focus_revenue)) 

```

## 4) Productivity calculation

Calculate the productivity variable by dividing the production by the farm size dedicated to the focus crop (in acre).

```{r, include = FALSE}

Data <- Data %>%
  
  mutate(across(c(cal_focus_quant_prod_kg, f_focus_crop_size_acre), as.numeric)) %>%
  mutate(f_focus_crop_size_acre = replace_na(f_focus_crop_size_acre, 0),
         cal_focus_productivity_acre = ifelse(f_focus_crop_size_acre > 0, cal_focus_quant_prod_kg/f_focus_crop_size_acre, NA))
```

## 5) Labour costs calculation

@warning: Looks like labour cost calculation is disappearing from the new data collections. We are in the final discussions of this, so leave it in the template for now, but when there is no calculation needed and we only keep one labour cost variable we should not include it in the calculated variables 

Here we calculate labor cost for temporary workers and for household using repeated group data about activities. after that, sum it by parent_index and store in a subset to be merged with "Data". then calculate the labour cost with and without household labour.

Note: Adjust code if f_labour_temporary_wage_per_day_activity refers to total and not per worker.

```{r}
#calculate labor cost for temporary workers using repeated group data about activities
# how: Calculate cal_labour_temporary_cost_activity, sum it by parent_index and store in a subset to be merged in "Data"

Data_labour_temporary <- Data_activities %>%
  mutate(cal_labour_temporary_cost_activity = f_labour_days_activity *  f_labour_temporary_workers_activity * 
           f_labour_temporary_wage_per_day_activity) %>%
  mutate(cal_labour_temporary_cost_activity = replace_na(cal_labour_temporary_cost_activity, 0)) %>%
  group_by(`_parent_index`) %>%
  summarize(cal_labour_temporary_cost = sum(cal_labour_temporary_cost_activity, na.rm = TRUE), .groups = 'drop') %>%
  mutate(cal_labour_temporary_cost = replace_na(cal_labour_temporary_cost, 0))
 
#calculate labor cost for household using repeated group data about activities
# Calculate cal_labour_cost_household_activity, sum it by parent_index and store in a subset to be merged in "Data"
Data_labour_household <- Data_activities %>%
  mutate(cal_labour_cost_household_activity_1 = f_labour_days_activity * f_labour_family_workers_activity * f_labour_temporary_wage_per_day_activity) %>%
  mutate(cal_labour_cost_household_activity_1 = replace_na(cal_labour_cost_household_activity_1, 0))%>%
  group_by(`_parent_index`) %>%
  summarize(cal_labour_cost_household_only = sum(cal_labour_cost_household_activity_1, na.rm = TRUE), .groups = 'drop') %>%
  mutate(cal_labour_cost_household_only = replace_na(cal_labour_cost_household_only, 0))
```

```{r}
 # Merge the summarized data back to the main dataset
Data <- Data %>%
  left_join(Data_labour_temporary, by = c("_index" = "_parent_index")) %>%
  left_join(Data_labour_household, by = c("_index" = "_parent_index"))
```

```{r}
# Calculate labour costs

Data <- Data %>%
  mutate(cal_labour_cost = f_crop_groups_labourer_costs + 
           f_crop_labour_permanent_costs + cal_labour_temporary_cost ,  
          cal_labour_cost = replace_na(cal_labour_cost,0)) 

# Calculate labour costs including household labour costs
Data <- Data %>%
  mutate(cal_labour_cost_incl_hhlabour = cal_labour_cost + cal_labour_cost_household_only,
         cal_labour_cost_incl_hhlabour = replace_na(cal_labour_cost_incl_hhlabour, 0))
```

Labor costs per acre

```{r}
#cost per acre
Data <- Data %>%
  # Calculate per kg input costs
  mutate(cal_labour_cost_acre = cal_labour_cost / f_focus_crop_size_acre) %>%
  # Replace infinite values with NA
  mutate(cal_labour_cost_acre = ifelse(is.infinite(cal_labour_cost_acre), NA, cal_labour_cost_acre)) %>%
  # Replace NA values with 0
  mutate(cal_labour_cost_acre = replace_na(cal_labour_cost_acre, 0))

Data <- Data %>%
  # Calculate per kg input costs
  mutate(cal_labour_cost_incl_hhlabour_acre = cal_labour_cost_incl_hhlabour / f_focus_crop_size_acre) %>%
  # Replace infinite values with NA
  mutate(cal_labour_cost_incl_hhlabour_acre = ifelse(is.infinite(cal_labour_cost_incl_hhlabour_acre), NA, cal_labour_cost_incl_hhlabour_acre)) %>%
  # Replace NA values with 0
  mutate(cal_labour_cost_incl_hhlabour_acre = replace_na(cal_labour_cost_incl_hhlabour_acre, 0))
```

**For more than one season**, below code is necessary

Labour cost is asked per season. We need to sum the costs given for each season.

@warning: do we need cost per season for labour including household labour cost?

```{r}
# #Labour cost per season
# Data <- Data %>%
#   mutate(cal_labour_cost = f_focus_labour_costs_season)
# 
# # FILL NA VALUES WITH 0
# Data$cal_labour_cost <- Data$cal_labour_cost %>% replace(is.na(.), 0)
```

```{r}
table(Data$f_focus_labour_rev_timeperiod)
```

```{r}
#harmonise season if not
Data <- Data %>%
  mutate(f_focus_labour_rev_timeperiod=ifelse(f_focus_labour_rev_timeperiod=="season 1 insert timeframe", "season 1",
                                       ifelse(f_focus_labour_rev_timeperiod== "season 2 insert timeframe", "season 2" ,
                                       ifelse(f_focus_labour_rev_timeperiod== "season 3 insert timeframe", "season 3" ,
                                              f_focus_labour_rev_timeperiod))))
```

```{r, include = FALSE}

# Create extra columns to define the quantities per season
Data <- Data %>%
  # Create new columns based on the season specified in f_focus_labour_rev_timeperiod
  mutate(
    cal_labour_cost_season_1 = ifelse(f_focus_labour_rev_timeperiod == "season 1", cal_labour_cost, NA),
    cal_labour_cost_season_2 = ifelse(f_focus_labour_rev_timeperiod == "season 2", cal_labour_cost, NA),
    cal_labour_cost_season_3 = ifelse(f_focus_labour_rev_timeperiod == "season 3", cal_labour_cost, NA)
#    cal_labour_cost_season_whole_year = ifelse(f_focus_labour_rev_timeperiod == "whole year", cal_labour_cost, NA)
    )


## Inbetween, adjust for repeated questions groups (IF APPLICABLE) ----  
  
##Adress values for those that have multiple seasons
Data <- Data %>%
#Identify duplicates
group_by(identifier, f_focus_labour_rev_timeperiod) %>% mutate(count_dup = n()) %>% #check whether we don't make mistakes here. For some cases farmer enter twice wrongly, in other cases entering same values for 2 seasons is ok.
mutate(count_dup = ifelse(is.na(f_focus_labour_rev_timeperiod), NA, count_dup)) %>%
#Identify those with multiple seasons
group_by(identifier, f_focus_labour_rev_timeperiod) %>% mutate(count_seasons = n()) %>%
mutate(count_seasons = ifelse(is.na(f_focus_labour_rev_timeperiod) | count_seasons > 1, NA, count_seasons)) %>%

    #Sum the labour cost for those that entered data for multiple seasons
group_by(identifier) %>%
  mutate(
    cal_labour_cost_season_1 = sum(na.omit(cal_labour_cost_season_1), na.rm = TRUE),
    cal_labour_cost_season_2 = sum(na.omit(cal_labour_cost_season_2), na.rm = TRUE),
    cal_labour_cost_season_3 = sum(na.omit(cal_labour_cost_season_3), na.rm = TRUE)
#    cal_labour_cost_season_whole_year = sum(na.omit(cal_labour_cost_season_whole_year), na.rm = TRUE)
    ) %>%

#Replace values with 0 for those that entered the data twice
mutate(`repeat no` = as.numeric(`repeat no`)) %>%
mutate(cal_labour_cost = ifelse(`repeat no` >1  & count_dup > 1, 0, cal_labour_cost)) %>%

#Sum the values for those that entered data for multiple seasons
group_by(identifier, count_seasons) %>%
mutate(cal_labour_cost =  sum(cal_labour_cost, na.rm = TRUE)) %>%

#Ensure we have 1 row of data for each farmer
mutate(cal_labour_cost = ifelse(`repeat no` >1 , NA, cal_labour_cost)) %>%
ungroup() %>% select(-count_dup, -count_seasons)
```

## 6) Input costs calculation

Input costs are asked per season. This code sums up the costs for seasons to arrive at a total input cost.

```{r, include = FALSE}
#cost per season
Data <- Data %>%
  mutate_at(vars(starts_with("f_inputs_cost")), as.numeric) %>%
  mutate_at(vars(starts_with("f_inputs_cost")), ~ifelse(is.na(.), 0, .))
  
#check if some inputs variables are asked per land unit and make adjustments
# Data <- Data %>%
#   # Calculate inputs costs per season for those in per hectare
#   mutate(cal_inputs_costs_insect_season = f_inputs_costs_insect_season_per_hectare * f_focus_crop_size_hectare,
#          cal_inputs_costs_irrigation_season = f_inputs_costs_irrigation_season_per_hectare * f_focus_crop_size_hectare,
#          cal_inputs_costs_biological_control_season = f_inputs_costs_biological_control_season_per_hectare * f_focus_crop_size_hectare,
#          cal_inputs_costs_other_season = f_inputs_costs_other_season_per_hectare * f_focus_crop_size_hectare)

#calculate input costs
Data <- Data %>%
  mutate(cal_inputs_costs = Data %>% 
           select(starts_with("f_inputs_cost")) %>%
           rowSums(na.rm=TRUE)) 
```

```{r}
table(Data$f_focus_inputs_rev_timeperiod)
```

```{r}
#harmonise season if not
Data <- Data %>%
  mutate(f_focus_inputs_rev_timeperiod=ifelse(f_focus_inputs_rev_timeperiod=="season 1 insert timeframe", "season 1",
                                       ifelse(f_focus_inputs_rev_timeperiod== "season 2 insert timeframe", "season 2" ,
                                       ifelse(f_focus_inputs_rev_timeperiod== "season 3 insert timeframe", "season 3" ,
                                              f_focus_inputs_rev_timeperiod))))
```

```{r, include = FALSE}

# Create extra columns to define the quantities per season
Data <- Data %>%
  # Create new columns based on the season specified in f_focus_inputs_rev_timeperiod
  mutate(
    cal_inputs_costs_season_1 = ifelse(f_focus_inputs_rev_timeperiod == "season 1", cal_inputs_costs, NA),
    cal_inputs_costs_season_2 = ifelse(f_focus_inputs_rev_timeperiod == "season 2", cal_inputs_costs, NA),
    cal_inputs_costs_season_3 = ifelse(f_focus_inputs_rev_timeperiod == "season 3", cal_inputs_costs, NA))

# In between ,adjust for RQG
Data <- Data %>%
  #Identify duplicates
  group_by(identifier, f_focus_inputs_rev_timeperiod) %>% mutate(count_dup = n()) %>%
  mutate(count_dup = ifelse(is.na(f_focus_inputs_rev_timeperiod), NA, count_dup)) %>%
  #Identify those with multiple seasons
  group_by(identifier, f_focus_inputs_rev_timeperiod) %>% mutate(count_seasons = n()) %>%
  mutate(count_seasons = ifelse(is.na(f_focus_inputs_rev_timeperiod) | count_seasons > 1, NA, count_seasons)) %>%
  
  #Sum the labour cost for those that entered data for multiple seasons
group_by(identifier) %>%
  mutate(
    cal_inputs_costs_season_1 = sum(na.omit(cal_inputs_costs_season_1), na.rm = TRUE),
    cal_inputs_costs_season_2 = sum(na.omit(cal_inputs_costs_season_2), na.rm = TRUE),
    cal_inputs_costs_season_3 = sum(na.omit(cal_inputs_costs_season_3), na.rm = TRUE)) %>%
  
  #Replace values with 0 for those that entered the data twice
  mutate(`repeat no` = as.numeric(`repeat no`)) %>%
  mutate(cal_inputs_costs = ifelse(`repeat no` >1  & count_dup > 1, 0, cal_inputs_costs)) %>%
  
  #Sum the values for those that entered data for multiple seasons
  group_by(identifier, count_seasons) %>%
  mutate(cal_inputs_costs =  sum(cal_inputs_costs, na.rm = TRUE)) %>%
  
  #Ensure we have 1 row of data for each farmer
  mutate(cal_inputs_costs = ifelse(`repeat no` >1 , NA, cal_inputs_costs)) %>%
  ungroup() %>%
  select(-count_dup, -count_seasons)
```

```{r}
input_costs_subset <- Data %>% select(c(f_inputs_costs_chemicals_season, f_inputs_costs_fertilizer_season, f_inputs_costs_seeds_season, cal_inputs_costs))
```

```{r}
#cost per acre
# Data <- Data %>%
#   # Calculate per kg input costs
#   mutate(cal_inputs_costs_acre = cal_inputs_costs / f_focus_crop_size_acre) %>%
#   # Replace infinite values with NA
#   mutate(cal_inputs_costs_acre = ifelse(is.infinite(cal_inputs_costs_acre), NA, cal_inputs_costs_acre)) %>%
#   # Replace NA values with 0
#   mutate(cal_inputs_costs_acre = ifelse(is.na(cal_inputs_costs_acre), 0, cal_inputs_costs_acre))
```

## 7) Other costs calculation

```{r}
# Fill all NA values 
variables_to_replace <- c("f_focus_costs_irrigation", "f_focus_costs_energy",
                          "f_costs_land_focuscrop", "f_focus_costs_storage",
                          "f_focus_costs_marketing", "f_focus_costs_transporation")

# Replace NA values with 0 for the specified variables using dplyr
Data <- Data %>%
  mutate_at(vars(all_of(variables_to_replace)), ~replace_na(., 0))

# Calculation
Data <- Data %>%
  mutate(cal_focus_other_costs = f_focus_costs_irrigation + f_focus_costs_energy + f_costs_land_focuscrop + f_focus_costs_storage + f_focus_costs_marketing + f_focus_costs_transporation)
```

```{r}
#cost per acre if needed
# Data <- Data %>%
#   # Calculate per kg input costs
#   mutate(cal_focus_other_costs_acre = cal_focus_other_costs / f_focus_crop_size_acre) %>%
#   # Replace infinite values with NA
#   mutate(cal_focus_other_costs_acre = ifelse(is.infinite(cal_focus_other_costs_acre), NA, cal_focus_other_costs_acre)) %>%
#   # Replace NA values with 0
#   mutate(cal_focus_other_costs_acre = ifelse(is.na(cal_focus_other_costs_acre), 0, cal_focus_other_costs_acre))
```

## 8) Total cost focus crop

@warning: outlier detection applied

```{r}
Data <- Data %>%
    mutate(cal_focus_cost = cal_labour_cost + cal_inputs_costs + cal_focus_other_costs,
           cal_focus_cost = replace_na(cal_focus_cost, 0)) 
# Apply outlier detection for cal_focus_cost, as there are a few extreme outliers 
Data <- Data %>%
  mutate(
    cal_focus_cost = outlier_detection(cal_focus_cost)
  )
```

```{r}
#cost per acre if needed
# Data <- Data %>%
#   # Calculate per kg input costs
#   mutate(cal_focus_cost_acre = cal_focus_cost / f_focus_crop_size_acre) %>%
#   # Replace infinite values with NA
#   mutate(cal_focus_cost_acre = ifelse(is.infinite(cal_focus_cost_acre), NA, cal_focus_cost_acre)) %>%
#   # Replace NA values with 0
#   mutate(cal_focus_cost_acre = ifelse(is.na(cal_focus_cost_acre), 0, cal_focus_cost_acre))
```

## 9) Net-income focus crop

```{r}
Data <- Data %>%
  mutate(cal_focus_income = cal_focus_revenue - cal_focus_cost)
```

## 10) Net-income other crops

```{r}
# Clean data type and values from share variable
Data$f_othermaincrop_1_income_share <- as.numeric(Data$f_othermaincrop_1_income_share)
Data <- Data %>% mutate(f_othermaincrop_1_income_share = ifelse(f_othermaincrop_1_income_share == 10, 1, f_othermaincrop_1_income_share))

Data$f_othermaincrop_2_income_share <- as.numeric(Data$f_othermaincrop_2_income_share)
Data <- Data %>% mutate(f_othermaincrop_2_income_share = ifelse(f_othermaincrop_2_income_share == 10, 1, f_othermaincrop_2_income_share))
```

```{r}
# check for rows where cost is > 0 and income missing 
Data <- Data %>%
  mutate(f_othermaincrop_1_costs_labour = ifelse(is.na(f_othermaincrop_1_inc_sold), NA, f_othermaincrop_1_costs_labour)) %>%
  mutate(f_othermaincrop_1_costs_inputs = ifelse(is.na(f_othermaincrop_1_inc_sold), NA, f_othermaincrop_1_costs_inputs)) %>%
  mutate(f_othermaincrop_1_costs_transport = ifelse(is.na(f_othermaincrop_1_inc_sold), NA, f_othermaincrop_1_costs_transport)) %>%
  
  mutate(f_othermaincrop_2_costs_labour = ifelse(is.na(f_othermaincrop_2_inc_sold), NA, f_othermaincrop_2_costs_labour)) %>%
  mutate(f_othermaincrop_2_costs_inputs = ifelse(is.na(f_othermaincrop_2_inc_sold), NA, f_othermaincrop_2_costs_inputs)) %>%
  mutate(f_othermaincrop_2_costs_transport = ifelse(is.na(f_othermaincrop_2_inc_sold), NA, f_othermaincrop_2_costs_transport)) 
```

```{r, include = FALSE}
# Fill NA's 
variables_to_replace <- c("f_othermaincrop_1_costs_labour", "f_othermaincrop_1_costs_inputs",
                          "f_othermaincrop_1_costs_transport", "f_othermaincrop_2_costs_labour"                       ,"f_othermaincrop_2_costs_inputs", "f_othermaincrop_2_costs_transport")
Data <- Data %>%
  mutate_at(vars(all_of(variables_to_replace)), ~replace_na(., 0))

# calculation
Data <- Data %>%
  mutate(cal_othermaincrop_1_cost = f_othermaincrop_1_costs_labour + f_othermaincrop_1_costs_inputs + f_othermaincrop_1_costs_transport) %>%
  mutate(cal_othermaincrop_2_cost = f_othermaincrop_2_costs_labour + f_othermaincrop_2_costs_inputs + f_othermaincrop_2_costs_transport)

```

Following code calculates production value for other crops. This is only done in Living income studies! Check whether the code applies to this case.

```{r, include = FALSE}
# variables_to_replace <- c("f_othermaincrop_1_quant_prod", "f_othermaincrop_1_price",
#                           "f_othermaincrop_2_quant_prod", "f_othermaincrop_2_price")
# Data <- Data %>%
#   mutate_at(vars(all_of(variables_to_replace)), ~replace_na(., 0))
# 
# Data <- Data %>%
#   mutate(cal_othermaincrop_production_value = f_othermaincrop_1_quant_prod * f_othermaincrop_1_price + f_othermaincrop_2_quant_prod * f_othermaincrop_2_price)
```

Revenues from other crops:

```{r}
# Clean data type and values from share variable
Data$f_other_crop_income_share <- as.numeric(Data$f_other_crop_income_share)
Data <- Data %>% mutate(f_other_crop_income_share = ifelse(f_other_crop_income_share == 10, 1, f_other_crop_income_share))
```

```{r}
Data <- Data %>%
  mutate(cal_othermaincrop_1_inc_sold = replace_na(f_othermaincrop_1_inc_sold,0),
         cal_othermaincrop_2_inc_sold = replace_na(f_othermaincrop_2_inc_sold,0),
         cal_other_crop_income = replace_na(f_other_crop_income,0))
```

Net income calculation:

```{r}
Data <- Data %>%
  mutate(cal_other_crop_income = cal_othermaincrop_1_inc_sold - cal_othermaincrop_1_cost + cal_othermaincrop_2_inc_sold -  cal_othermaincrop_2_cost + cal_other_crop_income)
```

```{r}
# Subset to check calculations 
cal_otherinc_subset <- Data %>% select(c(cal_othermaincrop_1_inc_sold, cal_othermaincrop_1_cost, cal_othermaincrop_2_inc_sold, cal_othermaincrop_2_cost, cal_other_crop_income))
```

## 11) Net-income livestock calculation

```{r}
Data$f_livestock_income_share <- as.numeric(Data$f_livestock_income_share)

Data <- Data %>% mutate(f_livestock_income_share = ifelse(f_livestock_income_share == 10, 1, f_livestock_income_share))
```

```{r}
Data <- Data %>% 
  mutate(f_livestock_revenue_total = ifelse(f_livestock_income_share == 0, NA, f_livestock_revenue_total))
```

check the available information that can be include in variable to replace, then adapt the code

```{r}
variables_to_replace <- c("f_livestock_income_total", "f_livestock_nr_hired_labourers",
                         "f_livestock_days_hiredlabour", "f_livestock_wages_hiredlabour",                               "f_livestock_costs_other")
Data <- Data %>%
 mutate_at(vars(all_of(variables_to_replace)), ~replace_na(., 0))
#Code for this cas
# Data <- Data %>%
#   mutate_at(vars(f_livestock_income_total), ~replace_na(., 0))
# 
 Data <- Data %>%
   mutate(cal_livestock_revenue = f_livestock_income_total) %>%
 mutate(cal_livestock_labour_cost = (f_livestock_nr_hired_labourers * f_livestock_days_hiredlabour * f_livestock_wages_hiredlabour)) %>%
 mutate(cal_livestock_costs_other = f_livestock_costs_other) %>%
 mutate(cal_livestock_cost = cal_livestock_costs_other+ cal_livestock_labour_cost)

# Net income
Data <- Data %>%
  mutate(cal_livestock_income = cal_livestock_revenue - cal_livestock_cost,
         cal_livestock_income = replace_na(cal_livestock_income, 0))
```

```{r}
subset_livestock <- Data %>%
  select(c(
    f_livestock_nr_hired_labourers,
    f_livestock_days_hiredlabour,
    f_livestock_wages_hiredlabour,
    f_livestock_costs_other,
    cal_livestock_cost,
    cal_livestock_revenue,
    cal_livestock_income
  ))
```

## 12) General farm costs calculation

```{r}
variables_to_replace <- c("f_equip_costs", "hh_loan_one_size",
                          "hh_loan_one_value_interest", "hh_loan_two_size",                                              "hh_loan_two_value_interest")

Data <- Data %>%
  mutate_at(vars(all_of(variables_to_replace)), ~replace_na(., 0))%>%
#  mutate_at(vars(f_equip_costs), ~replace_na(., 0))

Data <- Data %>% 
  mutate(cal_equipment_costs = f_equip_costs) %>%
  mutate(cal_equipment_costs = ifelse(is.na(cal_equipment_costs), 0, cal_equipment_costs)) %>%
  
  mutate(loan_1_cost = ifelse(hh_loan_one_value_interest == 0, 0, hh_loan_one_size * (10/hh_loan_one_value_interest))) %>%
  mutate(loan_2_cost = ifelse(hh_loan_two_value_interest == 0, 0, hh_loan_two_size * (10/hh_loan_two_value_interest))) %>%
  
  mutate(cal_farm_costs_loans = loan_1_cost + loan_2_cost) %>%
  mutate(cal_farm_costs_loans = ifelse(is.na(cal_farm_costs_loans), 0, cal_farm_costs_loans)) 

# total costs 
Data <- Data %>% mutate(cal_farm_costs_general = cal_equipment_costs + cal_farm_costs_loans)

# Delete intermediate variables 
Data <- Data %>% select(-c(loan_1_cost, loan_2_cost))

```

```{r}
subset_general_costs <- Data %>%
  select(c(
    hh_loan_one_size,
    hh_loan_one_value_interest,
    hh_loan_two_size,
    hh_loan_two_value_interest,
    f_equip_costs,
    cal_equipment_costs,
    cal_farm_costs_loans
  ))
```

## 13) Off-farm and other income calculation

check and add any variable that should be considered

```{r}
variables_to_replace <- c("f_nonfarm_enterpr_income_month", "f_income_offfarmlabour_month")
Data <- Data %>%
  mutate_at(vars(all_of(variables_to_replace)), ~replace_na(., 0))

Data <- Data %>%
  mutate(cal_offfarm_income = 12*(f_nonfarm_enterpr_income_month + f_income_offfarmlabour_month+ f_income_other_month))

```

## 14) Farm income calculation

```{r}
Data <- Data %>%
  mutate(cal_farm_income = cal_focus_income + cal_other_crop_income + cal_livestock_income - cal_farm_costs_general,
         cal_farm_income = replace_na(cal_farm_income, 0))
```

## 15) Actual income calculation

There are different approaches to calculating the actual income. The first version is the default. Use this approach, unless communicated otherwise.

```{r}
Data <- Data %>%
#First approach for actual income, based on as many direct inputed values of the farmer.
 mutate(
   cal_actual_income = cal_focus_income + cal_other_crop_income + cal_livestock_income - cal_farm_costs_general + cal_offfarm_income) %>%
 mutate(
#Set cal_actual_income to missing (NA) if cal_focus_income is 0 or missing
   cal_actual_income = ifelse(is.na(cal_focus_income) | cal_focus_income == 0 | f_focus_quant_sold==0 | is.na(f_focus_quant_sold) | f_focus_measurement_sold=="" , NA, cal_actual_income))
```

```{r}
# Clean data type and values from share variable
#Data$f_focus_income_share <- as.numeric(Data$f_focus_income_share)
#Data <- Data %>% mutate(f_focus_income_share = ifelse(f_focus_income_share == 10, 1, f_livestock_income_share))
```

```{r}
#Data <- Data %>% 
  # Second approach for actual income, based on the income share of farmers
#  mutate(
#    cal_actual_income_v2 = cal_focus_income * (10/(as.numeric(f_focus_income_share)))) %>%
#  mutate(
    # Set cal_actual_income_v2 to missing (NA) if cal_focus_income is 0 or missing
#    cal_actual_income_v2 = ifelse(is.na(cal_focus_income) | cal_focus_income == 0 | f_focus_quant_sold==0 | #is.na(f_focus_quant_sold) | f_focus_measurement_sold==""  | f_focus_income_share == 0, NA, cal_actual_income_v2))

```

```{r}
# make a check file to see whether everything went correct

subset <- Data %>% 
  select(cal_focus_quant_prod_kg, cal_focus_quant_sold_kg, cal_focus_price, 
         cal_focus_quant_own_consumption_kg, cal_focus_quant_lost_kg, 
         cal_focus_revenue, cal_focus_productivity_acre,cal_labour_cost, cal_inputs_costs, cal_focus_other_costs, cal_focus_cost, cal_focus_income, cal_othermaincrop_1_cost, cal_othermaincrop_2_cost, cal_othermaincrop_production_value,
cal_othermaincrop_1_inc_sold, cal_othermaincrop_2_inc_sold,cal_other_crop_income, cal_livestock_income, cal_equipment_costs, cal_farm_costs_loans, 
cal_farm_costs_general, cal_offfarm_income, cal_actual_income)
 
#cal_actual_income_v2 , cal_actual_income_v3)

write.xlsx(subset, "calculated_variables_script2.0.xlsx")
```

# Section 3 Descriptive statistics

## 1) Net Promotor score

```{r, include = FALSE}
hh_farmer_gender <- c("all farmers") 
    
    NSP_total <- Data %>%
      select(index, cs_recommendation) %>% 
      mutate(cs_recommendation = ifelse(is.na(cs_recommendation), "no input",cs_recommendation)) %>%
      mutate(detractor = ifelse(cs_recommendation == "not likely"| cs_recommendation == "somewhat likely"| cs_recommendation == "likely",1,0),
             promoter = ifelse(cs_recommendation == "very likely", 1,0),
             passive = ifelse(cs_recommendation == "most likely"| cs_recommendation == "i dont know",1,0),
             nr_recommenders = ifelse(cs_recommendation == "no input", 0,1)) %>%
      summarize(nr_promoters = sum(promoter),
                nr_detractors = sum(detractor),
                nr_passive = sum(passive),
                nr_farmers = sum(nr_recommenders)) %>%
      mutate(nsp_total = round((nr_promoters/nr_farmers) - (nr_detractors/nr_farmers),2),
             hh_farmer_gender = hh_farmer_gender)
    
    NSP_by_gender <- Data %>%
      select(index, cs_recommendation, hh_farmer_gender) %>% 
      mutate(cs_recommendation = ifelse(is.na(cs_recommendation), "no input",cs_recommendation)) %>%
      mutate(detractor = ifelse(cs_recommendation == "not likely"| cs_recommendation == "somewhat likely"| cs_recommendation == "likely",1,0),
             promoter = ifelse(cs_recommendation == "very likely", 1,0),
             passive = ifelse(cs_recommendation == "most likely"| cs_recommendation == "i dont know",1,0),
             nr_recommenders = ifelse(cs_recommendation == "no input", 0,1)) %>%
      group_by(hh_farmer_gender) %>%
      summarize(nr_promoters = sum(promoter),
                nr_detractors = sum(detractor),
                nr_passive = sum(passive),
                nr_farmers = sum(nr_recommenders)) %>%
      mutate(nsp_gender = round((nr_promoters/nr_farmers) - (nr_detractors/nr_farmers),2))
    
    NSP <- full_join(NSP_total, NSP_by_gender)
    NSP <- NSP %>% select(hh_farmer_gender, nr_farmers, nr_promoters, nr_detractors,nr_passive, nsp_total, nsp_gender)
    
```

## 2) Anonymise data for further use

```{r, include = FALSE}
Data <- Data %>%
          rename(location_cascade_region = pi_location_cascade) %>%  ### the variable on the right differs from case to case!!!
          select(
      -c(starts_with("pi_"), -contains("county")),
      -c(name_of_farmer)) %>%
          rename(pi_location_cascade_first_level = location_cascade_region)
```

## 3) Summary statistics

### All Farmers: numerical descriptives

```{r, include = FALSE}
farmer_type <- c("all farmers")
all_var <- Data %>% 
  select(index) %>% 
  table() %>% 
  melt(c("farmer type"), value.name="n") %>%
  mutate(`farmer type` = farmer_type)

numerical_descriptives_all_farmers <- Data %>%
  select_if(is.numeric) %>%
  summarise_each(funs(round(mean(., na.rm = TRUE),2))) %>%
  melt(value.name="mean") %>%
  left_join(
    Data %>% 
      select_if(is.numeric) %>%
      summarise_each(funs(round(sd(., na.rm = TRUE),2))) %>%
      melt(value.name="sd")) %>%
  left_join(
    Data %>% 
      select_if(is.numeric) %>%
      summarise_each(funs(min(., na.rm = TRUE))) %>%
      melt(value.name="min")
  ) %>% 
  left_join(
    Data %>% 
      select_if(is.numeric) %>%
      summarise_each(funs(round(max(., na.rm = TRUE),2))) %>%
      melt(value.name="max")
  ) %>% 
  left_join(
    Data %>% 
      select_if(is.numeric) %>%
      summarise_each(funs(count_n))  %>%
      melt(value.name="freq")
  ) %>%
  left_join(survey_questions) %>%
  select("variable", "freq", "mean","sd", "min","max") 

```

### All farmers: single categorical descriptives

```{r, include = FALSE}
single_mc <- survey_questions %>%
  filter(grepl("^select_one", type)) %>%  # Filter select_one questions
  pull(name)  # Extract the variable names

single_categorical_descriptives_all_farmers <- all_var

for(i in single_mc){
  
  if(any(names(Data) %in% i)){
    
    frequencies <- Data %>% 
      select(all_of(i)) %>%       
      table() %>% 
      melt(c("category"),value.name = "freq") %>%
      mutate(n = nr_participants_raw) %>%
      mutate(`farmer type` = farmer_type) %>%
      mutate("variable" = i) %>%
      left_join(all_var) %>%
      mutate("%" = round(freq/n,2)*100) %>%
      mutate(category = as.character(category))
    
    single_categorical_descriptives_all_farmers <- single_categorical_descriptives_all_farmers %>% 
      full_join(frequencies) %>%
      select(variable, `farmer type`, n, category, freq, "%")
    
  }
}
```

### All farmers: multiple categorical descriptives

```{r, include = FALSE}
multiple_mc <- survey_questions %>%
  filter(grepl("^select_multiple", type)) %>%  # Filter select_multiple questions
  pull(name)  # Extract the variable names
multiple_categorical_descriptives_all_farmers <- all_var

for (j in multiple_mc) {
  print(j)
  
  # Skip the variable that do not work for this code (empty for example)
  # if (j == "f_labour_otheractivity_labour_type") {
  #   next
  # }
  # if (j == "hh_loan_one_agri_purpose") {
  #   next
  # }
  # if (j == "hh_loan_mulitple_largest_purpose") {
  #   next
  # }
  if (any(names(Data) %in% j)) {
    frequencies <- Data %>%
      select(all_of(j)) %>%
      cSplit(j, "|") %>%
      gather(key, value) %>%
      select(-key) %>%
      table() %>%
      melt(c("category"), value.name = "freq") %>%
      mutate(n = nr_participants_raw) %>%
      mutate("variable" = j) %>%
      left_join(all_var) %>%
      mutate("%" = round(freq / n, 2) * 100) %>%
      mutate(category = as.character(category))
    
    multiple_categorical_descriptives_all_farmers <- multiple_categorical_descriptives_all_farmers %>%
      full_join(frequencies) %>%
      select(variable, `farmer type`, n, category, freq, "%")
  }
}

```

### By gender: numerical descriptives

```{r, include=FALSE}
gender_var <- Data %>% 
  select(hh_farmer_gender) %>% 
  table() %>% 
  melt("hh_farmer_gender", value.name="n")

numerical_descriptives_by_gender <- Data %>%
  group_by(hh_farmer_gender) %>%
  select_if(is.numeric) %>%
  summarise_each(funs(round(mean(., na.rm = TRUE),2))) %>%
  melt(value.name="mean") %>%
  left_join(
    Data %>% 
      group_by(hh_farmer_gender) %>%
      select_if(is.numeric) %>%
      summarise_each(funs(round(sd(., na.rm = TRUE),2))) %>%
      melt(value.name="sd")) %>%
  left_join(
    Data %>% 
      group_by(hh_farmer_gender) %>%
      select_if(is.numeric) %>%
      summarise_each(funs(min(., na.rm = TRUE))) %>%
      melt(value.name="min")
  ) %>% 
  left_join(
    Data %>% 
      group_by(hh_farmer_gender) %>%
      select_if(is.numeric) %>%
      summarise_each(funs(round(max(., na.rm = TRUE),2))) %>%
      melt(value.name="max")
  ) %>% 
  left_join(
    Data %>% 
      group_by(hh_farmer_gender) %>%
      select_if(is.numeric) %>%
      summarise_each(funs(count_n))  %>%
      melt(value.name="freq")
  ) %>%
  left_join(survey_questions) %>%
  left_join(gender_var) %>%
  select("variable","hh_farmer_gender","n", "freq", "mean","sd", "min","max") 

```

### By gender: single categorical descriptives

```{r, include = FALSE}

single_mc <- survey_questions %>%
  filter(grepl("^select_one", type)) %>%  # Keep only single-choice questions
  filter(name != "hh_farmer_gender") %>%  # Exclude gender variable
  pull(name)  # Extract variable names

single_categorical_descriptives_by_gender <- gender_var

for(i in single_mc){
  
  if(any(names(Data) %in% i)){
    
    frequencies <- Data %>% 
      select(hh_farmer_gender, all_of(i)) %>% 
      table() %>% 
      melt(c("hh_farmer_gender","category"), value.name="freq") %>%
      mutate("variable" = i) %>%
      left_join(gender_var) %>%
      mutate("%" = round(freq/n,2)*100) %>%
      mutate(category = as.character(category))
    
    single_categorical_descriptives_by_gender <- single_categorical_descriptives_by_gender %>% 
      full_join(frequencies) %>%
      select(variable, hh_farmer_gender, n, category, freq, "%")
  }
}
```

### By gender: multiple categorical descriptives

```{r, include = FALSE}

multiple_mc <- survey_questions %>%
  filter(grepl("^select_multiple", type)) %>%  # Filter select_multiple questions
  filter(name != "hh_farmer_gender") %>%  # Exclude gender variable
  pull(name)  # Extract the variable names

multiple_categorical_descriptives_by_gender <- gender_var

for(j in multiple_mc){
  print(j)
  #remove variable not working for this code
  # if (j == "f_labour_otheractivity_labour_type") {
  #   next
  # }
  # if (j == "hh_loan_mulitple_largest_purpose") {
  #   next
  # }
  if(any(names(Data) %in% j)){
    
    frequencies <- Data %>% 
      select(hh_farmer_gender, all_of(j)) %>% 
      cSplit(j, "|") %>%
      gather(key, value, -hh_farmer_gender) %>%
      select(-key) %>% table() %>%
      melt(c("hh_farmer_gender","category"), value.name="freq") %>%
      mutate("variable" = j) %>%
      left_join(gender_var) %>%
      mutate("%" = round(freq/n,2)*100) %>%
      mutate(category = as.character(category))
    
    multiple_categorical_descriptives_by_gender <- multiple_categorical_descriptives_by_gender %>% 
      full_join(frequencies) %>%
      select(variable, hh_farmer_gender, n, category, freq, "%")
  }
}
```

# Section 4: Final checking

## 1) Check completeness of the codebook

All variables that are in the data should get a description in the codebook. That's why we check this and correct/ add where missing. We also check whether we have all the variables that are required for the data delivery.

```{r, include = FALSE}
question_library <- question_library %>%
    dplyr::rename(label = "Text",  # check if language is specified
                  name = "Variable name",
                  type = "Question type") %>%
    mutate_all(tolower) %>%
    select(label,
           name,
           type)

unmatched <- list()
```

## 2) Remove repeated rows

Remove repeated rows for household members and create columns for each household member (max household number is 15). Delete the unnecessary, only if household roster questions are asked, check also which ones are used. @Warning: to be updated properly with data

```{r, include = FALSE}
if("uuid" %in% colnames(Data)){     
    Data <- Data %>%
      group_by(uuid) %>%
      mutate(id = row_number())
}
#    for (nr in c(1:15)){
      
      ### ---- delete the unnecessary --- only if household roster questions are asked, check also which ones are used
#      hh_focuscrop_nr <- paste0("hh_focuscrop_", nr)
      
#      Data <- Data %>%
        #Delete the rows that do not apply
#        mutate(
#          !!sym(hh_focuscrop_nr) := ifelse(id == nr, hh_focuscrop_hrs, NA)) %>%
        
        #Delete the rows that do not apply
#        fill(!!sym(hh_focuscrop_nr)) %>%
#        fill(!!sym(hh_focuscrop_nr), .direction = "up") %>%
        
        #Delete the rows that do not apply
#        mutate(
#          !!sym(hh_focuscrop_nr) := ifelse(id >1 , NA, !!sym(hh_focuscrop_nr) ))
      
#    }
#  }
  
  Data <- Data %>%
    filter(id == 1) %>%
    select(-id,
           #-hh_member_birthyear,
           #-hh_member_gender,
           #-hh_member_education,
           
           -hh_focuscrop_hrs)

```

Let's check the variable names. First we need a dataframe with all variable names, and

```{r, include = FALSE}
#Make a dataframe listing all variables 
variable <-ls(Data)
data <- data.frame(variable)

## ---- Variables ending with other  ---

#Check if data variable is in codebook        
data$compare <-data$variable  %in%  survey_questions$variable 

#if it's a "other variable", do not remove
data <- data %>%
  mutate(compare = ifelse(grepl('_other$',variable) & compare == FALSE , FALSE, TRUE)) %>%
  filter(compare == FALSE) 

survey_questions <- bind_rows(survey_questions, data)
survey_questions <- survey_questions %>%
  arrange(variable)  %>%
  fill(label) %>%
  mutate(type = ifelse(!is.na(compare), "text",type)) %>%
  
  mutate(variable_2 = str_remove(variable,'_other$')) %>%
  mutate(same = ifelse(variable_2== lag(variable_2), 1, 0)) %>%
  
  mutate(label = ifelse(!is.na(compare) & same == 0 , "no question available", label)) %>%
  select(-compare, -variable_2, -same)
```

Check if it is a calculated variable or a variable from the question library.

```{r}
variable <-ls(Data)
data <- data.frame(variable)
data$compare <-data$variable  %in%  survey_questions$variable 
data <- data %>%
  filter(compare == FALSE) %>%
  select(-compare)

data$compare <-data$variable  %in%  vars_transformed$variable 

#check whether there is a match by checking out the "data" dataset MANUALLY
#if a variable is not in the vars_transformed, update the excel with variable transformations
```

Append the survey questions with the calculated variables

```{r}
#One changes are applied, append the codebook with information from the calculated variables (vars_transformed)
library(dplyr)

# Assuming "data" and "vars_transformed" are your dataframes

vars_calculated <- data$variable

calculated_variables <- vars_transformed %>%
  filter(variable %in% vars_calculated)

survey_questions <- survey_questions %>%
  bind_rows(calculated_variables)

```

Check whether its a household demographics variable

```{r}
#Check whether already in the codebook
variable <-ls(Data)
data <- data.frame(variable)
data$compare <-data$variable  %in%  survey_questions$variable 
data <- data %>%
  filter(compare == FALSE) 

```

If indeed household demographics variable, append the codebook with that information

```{r}
data <- data %>%
  filter(variable %in% household_demographics$variable) %>%
  select(-compare)

data <- merge(data, household_demographics, by.x = "variable")
survey_questions <- bind_rows(survey_questions, data)
```

```{r, include = FALSE}
# --- Check household demographic questions ---
  hh_demo <- survey_questions %>%
    filter(str_detect(name, 'hh_member_')) %>%
    arrange(name)

  survey_questions <- survey_questions %>%
    filter(!str_detect(name, 'hh_member_')) 
  survey_questions <- bind_rows(survey_questions, hh_demo)
  
```

Check whether we have all the required variables for the portal

```{r}
# ---- dashboard variables ----
  #All variables in delivered data into dataframe
  
  variable <-ls(Data)
  data <- data.frame(variable)
  
  #Check if data variable is dashboard list     
  vars_dashboard$compare <- vars_dashboard$latest_var %in% data$variable 
  
  data <- vars_dashboard %>%
    filter(!is.na(latest_var)) %>%
    filter(compare == FALSE)

```

Prepare final list of unmatched vars

-   Check these by hand and ensure the variable names are aligned with

1)  the question library

2)  list of calculated variables

3)  Household demographic variables.

Ensure that all variables part of the cleaned data or dashboard variable names are described in the codebook.

```{r, include = FALSE}

variable <- ls(Data)
data <- data.frame(variable) %>%
  filter(
    !variable %in% c(survey_questions$name, vars_transformed$variable, question_library$name)
  )

```

## 3) Add match - column

When you are dealing with an endline case, we create a "match" column to indicate whether or not the farmer is recurring. PLEASE IGNORE THIS SECTION WHEN YOU ARE DEALING WITH A BASELINE CASE!

In the 5200 Farmfit Github folder, you can find a folder named "PDC 2.0 sampling". Look here for the pi\_ file of the baseline and copy to the case folder. We load in this dataset to match with current farmers and see which ones are recurring. @warning: about location, will be update based on the new github location

First load in the baseline farmers and only keep the phone numbers.

```{r}
baseline_farmers <- read_excel("pi_farmworks-baseline.xlsx")
# Only keep the phone number column for matching
baseline_farmers <- baseline_farmers %>% select(uuid, mobile_number_farmer)

# Retain only unique rows based on mobile_number_farmer
baseline_farmers <- baseline_farmers %>%
  distinct(mobile_number_farmer, .keep_all = TRUE)
```

Now we match the Data with these phone numbers.

```{r}
 Data <- Data %>% left_join(baseline_farmers, by="mobile_number_farmer")
```

And add a column to indicate the match

```{r}
# create now column to indicate whether there is a match or not
Data$cal_match <- ifelse(is.na(Data$uuid.y), FALSE, TRUE)
# Remove and rename columns that changed due to merging
Data <- Data %>% select(-uuid.y)
colnames(Data)[colnames(Data) == "uuid.x"] <- "uuid"
```

```{r}
# Delete phone number from dataset for anonymisation
Data <- Data %>%
          select(
      -c(mobile_number_farmer)) 
```

## 4) Combine the inputs for data delivery

```{r}

sets <- list(
    "Codebook" = survey_questions,
    "Cleaned Data" = Data,
    "Raw Data (anonymised)" = Data_raw, 
    "Num. desc. all farmers" = numerical_descriptives_all_farmers,
    "Cat. desc. single all farmers" = single_categorical_descriptives_all_farmers,
    "Cat. desc. multi all farmers" = multiple_categorical_descriptives_all_farmers,
    "Num. desc. by gender" = numerical_descriptives_by_gender,
    "Cat. desc. single by gender" = single_categorical_descriptives_by_gender,
    "Cat. desc. multi by gender" = multiple_categorical_descriptives_by_gender,
    "Net promoter score" = NSP)
  
write.xlsx (sets, file = (paste0(data_delivery)))
```

## 5) Get personal information sheet

```{r, include = FALSE}
## ---- Extract personal information ----
Data_raw <- read_excel(data_filename)

Data_raw <- Data_raw %>%
  select(-contains("--option--")) %>% #how to deal with that in kobo format?
  rename_all(funs(tolower)) %>%
  select(uuid,
         name_of_farmer,
         mobile_number_farmer,
         contains("pi_")) #-contains("ppi")) 


pi_info<- list("Personal information" = Data_raw)

write.xlsx(pi_info, file=pi_filename) #pi_filename was created in the beginning of the script


```

## 6) Productivity check

Create this file the first time you run the script to clean the data.

```{r}
#Productivity check

productivity <- Data %>%
    mutate(focus_product_min_sold = cal_focus_quant_prod_kg - cal_focus_quant_sold_kg) %>%

    select(uuid,
           enumerator,
           #`submission date`, ##MAKE SURE THIS VARIABLE IS NOT DELETED IN THE FIRST PIECE OF THE CODE.It should be deleted before sharing with IDH, but it should be kept when checking the productivity numbers.
           starts_with("pi_location_cascade_level"), #include the applicable variable, this differs per case
           f_unit_land,
           f_size,
           f_size_acre,
           f_focus_crop_size,
           f_focus_crop_size_acre,
           cal_focus_productivity_acre,
           f_focus_quant_prod,
           f_focus_measurement_prod,
           cal_focus_quant_prod_kg,
           f_focus_quant_sold,
           f_focus_measurement_sold,
           cal_focus_quant_sold_kg,
           focus_product_min_sold,
           f_focus_price,
           f_focus_own_consumption,
           f_focus_own_consumption_measurement,
           f_focus_quant_lost,
           f_focus_measurement_lost
           )
  
write.xlsx (productivity, file = "productivity_check.xlsx", overwrite = TRUE)

```
